title: linux Dynamic linking
date: 2015-05-24 13:59:53
categories:
- compiler
tags:
- linking

---

## 动态链接

动态链接英文是Dynamic Linking，需要解决空间浪费和更新困难这两个问题。最简单的办法就是把程序的模块相互划分开来，形成独立的文件，而不再将他们静态的链接在一起。简单地讲，就是不对那些组成程序的目标文件进行链接，等到程序要运行时才进行链接。也就是说，把链接这个过程推迟到了运行时再进行，这就是动态链接(Dynamic Linking)的基本思想。

动态链接还有一个特点，就是程序在运行时可以动态地选择加载各种程序模块，这个优点就是后来被人们用来制作程序的插件(plug-in)。

<!--more-->

比如某个公司开发完成了某个产品,它按照一定的规则制定好程序的接口，其他公司或者开发者可以按照这种接口来编写符合要求的动态链接文件。该产品程序可以动态地载入各种第三方开发的模块，在程序运行时动态地链接，实现程序的扩展。

动态链接也有很多的问题令人烦恼和费解的地方。很常见的一个问题是，当程序所依赖的某个模块更新后，由于新的模块与旧的模块之间接口不兼容，导致了原来的程序无法运行。

## 动态链接的基本实现

动态链接的基本思想是把程序按照模块拆分成各个相对独立的部分，在程序运行时才将他们链接在一起形成一个完成的程序，而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件。在linux 系统中，ELF动态链接文件被称为动态共享对象（DSO,Dynamic Shared Objects）,简称共享对象，他们一般都是以“.so”为扩展名的一些文件。而在windows系统中，动态链接文件被称为动态链接库(Dynamical Linking Library)，它们通常就是我们平时很常见的以“.dll”为扩展名的文件。

在Linux 中，常用的C语言库的运行库glibc，它的动态链接形式的版本保存在“/lib”目录下，文件名是“libc.so.6”。整个系统只保留一份C语言的动态链接文件。可以通过命令`ldd hello` 来查看hello可执行文件所依赖的动态链接文件。

```
[wyl@localhost readELF]$ ldd hello
	linux-gate.so.1 =>  (0x00d23000)
	libc.so.6 => /lib/libc.so.6 (0x002a3000)
	/lib/ld-linux.so.2 (0x001be000)
[wyl@localhost readELF]$ 
```

ldd 所告诉您的是：该 ELF 映像依赖于 linux-gate.so（一个特殊的共享对象，它处理系统调用，它在文件系统中无关联文件）、GNU C 库（libc.so）以及 Linux 动态加载器（因为它里面有共享库依赖项）。

动态链接要解决的一个主要问题就是装载时在虚拟空间的位置？为了实现动态链接，首先会遇到的问题就是共享对象的地址冲突问题，因为你没有办法规定说哪个贡献文件必须在哪个地址。但是程序模块中的指令和数据中包含一些绝对地址的引用。

> 装载时重定位

为了能够使共享对象可以在任意地址装载，我们首先想到的方法就是静态链接中的重定位。这个想法的基本思路是，在链接时，对所有绝对地址的引用不做重定位，而是把这一步推迟到装载时在完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址进行重定位。假设函数foor 相对于代码段的起始地址是0x100，当模块被装载到0x10000000,那么我们就可以确定foor的地址为0x10000100。这个时候，系统遍历模块中的重定位表，把所有对foor的地址引用都重定位到0x10000100。这种情况常被称为装载时重定位（Load Time Relocation），在windows 中，这种装载时重定位又被称为基址重置（Rebasing）。

但是装载时重定位的方法并不适合用来解决上面的共享对象中所存在的问题。可以想象，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程之间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因此指令被重定位后对于每个进程来讲是不一样的。当然，动态链接库中的可修改数据部分对于不同的进程来说有多个副本，所以他们可以采用装载时重定位的方法。

> 地址无关代码

Linux 和 gcc 支持这种装载时重定位的方法。我们在产生共享对象时，使用了两个gcc的参数“-shared”和“-fPIC”。

装载时重定位可以解决模块中有绝对地址引用的方法之一，但是他有一个很大的缺点就是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的优势。一种好的解决方法是，把指令中那些需要修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是地址无关代码技术（PIC, Position-indenpendent Code）。

那么产生地址相关代码都有哪些类型呢？

- 第一中是模块内部的函数调用，跳转等；
- 第二中是模块内部的数据访问，比如说模块中定义的全局变量，静态变量；
- 第三中模块外部的函数调用，跳转等；
- 第四种模块外部的数据访问，比如其他模块中定义的全局变量。 

----

测试用的源代码：
``` c test.c
static int a;
extern int b;

extern void ext();

void bar()
{
	a = 1;
	b = 2;
}

void foo()
{
	bar();
	ext();
}
```

 编译命令： `gcc -shared -fPIC test.c -o test.so`

使用`objdump -d test.so`查看反汇编的代码主要部分如下：

``` c
00000545 <__x86.get_pc_thunk.bx>:
 545:	8b 1c 24             	mov    (%esp),%ebx
 548:	c3                   	ret    
 549:	90                   	nop
 54a:	90                   	nop
 54b:	90                   	nop

0000054c <bar>:
 54c:	55                   	push   %ebp
 54d:	89 e5                	mov    %esp,%ebp
 54f:	e8 40 00 00 00       	call   594 <__x86.get_pc_thunk.cx>
 554:	81 c1 24 12 00 00    	add    $0x1224,%ecx
 55a:	c7 81 28 00 00 00 01 	movl   $0x1,0x28(%ecx)
 561:	00 00 00 
 564:	8b 81 f8 ff ff ff    	mov    -0x8(%ecx),%eax
 56a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
 570:	5d                   	pop    %ebp
 571:	c3                   	ret    

00000572 <foo>:
 572:	55                   	push   %ebp
 573:	89 e5                	mov    %esp,%ebp
 575:	53                   	push   %ebx
 576:	83 ec 04             	sub    $0x4,%esp
 579:	e8 c7 ff ff ff       	call   545 <__x86.get_pc_thunk.bx>
 57e:	81 c3 fa 11 00 00    	add    $0x11fa,%ebx
 584:	e8 13 fe ff ff       	call   39c <bar@plt>
 589:	e8 2e fe ff ff       	call   3bc <ext@plt>
 58e:	83 c4 04             	add    $0x4,%esp
 591:	5b                   	pop    %ebx
 592:	5d                   	pop    %ebp
 593:	c3                   	ret    

00000594 <__x86.get_pc_thunk.cx>:
 594:	8b 0c 24             	mov    (%esp),%ecx
 597:	c3                   	ret    
 598:	90                   	nop
 599:	90                   	nop
 59a:	90                   	nop
 59b:	90                   	nop
 59c:	90                   	nop
 59d:	90                   	nop
 59e:	90                   	nop
 59f:	90                   	nop
```

1. 类型一 模块内部的调用
这一种情况最简单，模块内部的调用。被调用的函数与调用者都处于一个模块，他们之间的位置是固定不变得。对于现代的系统，模块内部的跳转，函数调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令不需要重定位。
虽然看起来很容易解决，但是由于存在**全局符号介入（Global Symbol Interposition）问题**，还是不能简单的采用相对寻址。
2. 类型二 模块内部数据访问 
指令中不能包含对数据的直接寻址，那么唯一的办法就是相对寻址。我们知道，一个模块前面一般是若干个页的代码，后面紧跟着若干页的数据，数据和代码之间的相对位置是固定的。那么对数据的寻址只需要加上固定的偏移量就可以了。但是，现代的体系结构中，对数据的寻址没有相对于指令地址（PC）的寻址方式，所以ELF用了一个很巧妙地办法来得到当前的pc值，然后再加上一个偏移量就可以达到访问相应变量的目的了。
函数"__x86.get_pc_thunk.cx"，这个函数的作用是把返回地址的值放到ecx寄存器，即把call的下一条指令的地址放到ecx寄存器。
接着执行一条add指令和一条mov指令，可以看到变量a的地址是add指令地址（ecx）加上两个偏移量0x1224和ox28。加上ox1224是当前位置与数据段的偏移，而0x28为变量 a 在数据段的偏移量。如果这个模块被加载到0x10000000,那么变量a的实际地址将是0x10000000+0x554+0x1224+0x28。
3. 类型三 模块间数据访问
模块间的数据访问时比较麻烦的，这些模块间的全局变量的地址是跟模块装载地址有关的。ELF的做法是在数据段里面建立一个指向这些变量的指针数组，也成为全局偏移表（Global Offset Table,GOT）,当代码需要引用该全局变量时，可以通过GOT中相应的项间接引用。
当指令访问b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4字节的地址，链接器在装载模块时会查找每个变量所在的地址，然后填充GOT中的各项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在装载时被修改，每个程序都可以有独立的副本。
首先确定GOT相对于当前指令的偏移，然后从GOT表中得到变量b的地址。
![]( /img/blog/got.png)
通过`objdump -R test.so`可以看到变量b的重定位信息。
	
	[wyl@localhost Code]$ objdump -R test.so

	test.so:     file format elf32-i386
	
	DYNAMIC RELOCATION RECORDS
	OFFSET   TYPE              VALUE 
	00001794 R_386_RELATIVE    *ABS*
	00001760 R_386_GLOB_DAT    __gmon_start__
	00001764 R_386_GLOB_DAT    _Jv_RegisterClasses
	00001768 R_386_GLOB_DAT    _ITM_deregisterTMCloneTable
	0000176c R_386_GLOB_DAT    _ITM_registerTMCloneTable
	00001770 R_386_GLOB_DAT    b

4. 类型四 模块间调用、跳转
我们可以采用类似上面类型三的方法，不过不同的是，GOT表中相应的项保存的是目标函数的地址。这种方法很简单，但是存在一些性能问题，实际上ELF采用了一种更加复杂和精巧的方法。

## 延迟绑定

我们知道，动态链接比静态链接慢的主要原因是，对于全局和静态的数据访问都要进行复杂的 GOT 定位，然后间接寻址；对于模块间的调用也要先定位GOT表。另一个原因是，动态链接工作在运行时，即程序开始执行时，动态链接器都要进行一次链接工作，动态链接器会寻找并装载所需要的共享对象，然后进行符号查找地址重定位等工作，这些工作也势必会减慢程序的启动速度。

在动态链接下，程序模块之间包含了大量的函数引用，所以在程序开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找以及重定位。不过可以想象，在一个程序的运行过程中，有可能很多函数在程序执行完时都不会被用到，比如一些错误处理函数或者用户很少用到的功能模块等，如果一开始就把所有函数都链接好实际上是一种浪费。所以ELF采用了一种叫做延迟绑定（Lazy Binding）的做法，基本思想就是当函数第一次被用到时才进行绑定（符号查找，重定位等）。这种做法可以大大加快程序的启动速度。

ELF使用PLT(Procedure Linkage Table)的方法实现。ELF 将 GOT 表拆分成两个表叫做“.got”和“.got.plt”。其中前者用来保存全局变量引用的地址，后者用来保存函数引用的地址，也就是说所有对外部函数的引用全部被分离出来放到了“.got.plt”中。
当我们调用某个外部模块的函数时，如果按照通常的做法应该是通过GOT中相应的项进行间接跳转。PLT为了实现延迟绑定，在这个过程中间又增加了一层间接跳转。调用函数并不直接通过GOT跳转，而是通过一个叫做PLT项的结构来进行跳转。每个外部函数在PLT中都有一个相应的项，比如bar()函数在PLT中的项叫做bar@plt。
逻辑上的实现：

``` 
bar@plt:
jmp *(bar@GOT)
push n
push moduleID
jump _dl_runtime_resolve 
```

第一条指令通过GOT间接跳转，bar@GOT表示GOT中保存bar()这个函数相应的项。如果链接器在初始化阶段已经初始化该项，并且将bar的地址填入到该项，那么这个跳转指令的结果就是我们所期望的，跳转到bar(),实现函数的正确调用。但是由于延迟绑定，链接器在初始化阶段并没有将bar的地址填入到该项，而是将上面代码中第二条指令“push n”的地址填入到bar@GOT中，这个步骤不需要查找任何符号，所以代价很低。很明显，第一条指令的效果是跳转到第二条指令，相当于没有进行任何操作。第二条指令时将一个数字 n 压入堆栈，这个数字是bar这个符号在重定位表“.rel.plt”中的下标。接着又是一条push指令将模块的ID压入到堆栈，然后跳转到_dl_runtime_resolve。然后调用_dl_runtime_resolve完成符号解析和重定位工作。_dl_runtime_resolve进行一系列工作以后将bar的真正地址填入到bar@GOT中。

一旦bar()这个函数被解析完毕，当我们再次调用bar@plt时，第一条jmp指令就能后跳转到真正的bar()函数中，bar()函数返回的时候会根据堆栈里面保存的EIP直接返回到调用者，而不会再继续执行bar@plt中第二条以后的指令，那段代码只会在符号未被解析时执行一次。

上面描述的是基本原理。实现时，“.got.plt”还有一个特殊的地方就是它的前三项是有特殊意义的。含义如下：

- 第一项保存的是“.dynamic”段的地址
- 第二项保存的是本模块的ID
- 第三项保存的是_dl_runtime_resolve()的地址。

其中，第二项和第三项又动态链接器在装载共享模块的时候负责将它们初始化。


``` c
0000039c <bar@plt>:
 39c:	ff a3 0c 00 00 00    	jmp    *0xc(%ebx)
 3a2:	68 00 00 00 00       	push   $0x0
 3a7:	e9 e0 ff ff ff       	jmp    38c <_init+0x30>

000003bc <ext@plt>:
 3bc:	ff a3 14 00 00 00    	jmp    *0x14(%ebx)
 3c2:	68 10 00 00 00       	push   $0x10
 3c7:	e9 c0 ff ff ff       	jmp    38c <_init+0x30>

```

## 运行过程

在动态链接情况下，操作系统还不能在装载完可执行文件之后就把控制权交给可执行文件的入口。因为我们知道可执行文件依赖很多共享文件，这个时候可执行文件里对于很多外部符号的引用还处于无效地址的状态。所以在映射完可执行文件之后，操作系统会先启动一个动态链接器（Dynamic Linker）。

动态链接器ld.so 实际也是一个共享对象。操作系统在加载完动态链接器后，就将控制权交给动态链接器的入口地址。然后动态链接器完成一系列自身的初始化操作，然后根据当前环境参数，开始对可执行文件进行链接工作。当所有动态链接工作完成之后，动态链接器会将控制权交到可执行文件的入口地址，程序开始正式执行。

动态链接器由ELF文件中的 .interp 段指出。

## 参考

- 程序员的自我修养
- [Linux 动态剖析](http://www.ibm.com/developerworks/cn/linux/l-dynamic-libraries/) 